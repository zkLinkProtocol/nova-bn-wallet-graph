type Token @entity {
  # token address
  id: Bytes!
  # token symbol
  symbol: String!
  # token name
  name: String!
  # token decimals
  decimals: BigInt!
}

type Pool @entity(immutable: false) {
  # pool address
  id: Bytes!
  # tokeX
  tokenX: Token!
  # tokenY
  tokenY: Token!
  # tokenX amount
  amountX: BigInt!
  # tokenY amount
  amountY: BigInt!
  # update timestamp
  blockTimestamp: BigInt!
  # update blocknumber
  blockNumber: BigInt!
  # update tx
  transactionHash: Bytes!
}

enum TransferType {
  Add
  Remove
}

type TransferActivity @entity(immutable: true) {
  id: Bytes!
  account: Bytes!
  type: TransferType!
  token: Bytes!
  amount: BigInt!
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type PoolTokenPosition @entity(immutable: false) {
  # user account + token address + poolId
  id: Bytes!
  # token address
  token: Bytes!
  # pool Address
  pool: Bytes!
  # total supply amount by user (used to calc the shared balance)
  amount: BigInt!
  # shared balance
  sharedBalance: BigInt!
  # user account
  tokenPosition: TokenPosition!
}

type TokenPosition @entity(immutable: false) {
  # user account + token address
  id: Bytes!
  # token address
  token: Bytes!
  # all related pool Position ,used to calculate the share balance
  poolPositions: [PoolTokenPosition!]! @derivedFrom(field: "tokenPosition")
  # token balance (UserPosition token total balance = balance + poolPositions shared balance)
  balance: BigInt!
  # user account
  userPosition: UserPosition!
}

type UserPosition @entity(immutable: false) {
  id: Bytes! # account
  tokenPositions: [TokenPosition!]! @derivedFrom(field: "userPosition")
}

type LayerBankMarket @entity(immutable: false) {
  id: Bytes! # account
  supply: BigInt!
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}

type AquaMarket @entity(immutable: false) {
  id: Bytes! # account
  supply: BigInt!
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  transactionHash: Bytes!
}
